<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/node-js/" itemprop="url">node.js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T19:29:55+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <style>
 div{
    padding:20px;
  }

  *{

  h3,h1,h2{
   color:yellowgreen;
   font:30px '隶书';
  }
  u{
   color:red;
   font-size:14px;

  }

</style>

<h3 id="npm（包管理工具）"><a href="#npm（包管理工具）" class="headerlink" title="npm（包管理工具）"></a>npm（包管理工具）</h3><ul>
<li>npm init -y  初始化，生成一个包管理文件（package.json:用于依赖文件的赋值）;</li>
<li>npm install  报名@版本号（版本号可选） –save或者（–save/dev）   ///install 可以简写成i<ul>
<li>–save 表示将包安装到部署依赖（开发和项目上线都需要依赖的包），可以简写成 -S</li>
<li>–save-dev表示安装到开发依赖（只在项目开发中依赖），可以简写成 -D</li>
</ul>
</li>
<li><p>npm uninstall 包名 –save/–save-dev //删除包,同时删除package.json中的记录；</p>
</li>
<li><p>想要通过package.json来自动安装包 ，在其所对的文件夹中执行对应指令：npm install</p>
</li>
</ul>
<h3 id="EMAscript"><a href="#EMAscript" class="headerlink" title="EMAscript"></a>EMAscript</h3><ul>
<li>只规定了如何进行分支判断，如何定义变量，如何定义方法；</li>
<li>只是一个规范，不是编程语言；</li>
</ul>
<h3 id="ES6新语法特性；"><a href="#ES6新语法特性；" class="headerlink" title="ES6新语法特性；"></a>ES6新语法特性；</h3><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="相关定义："><a href="#相关定义：" class="headerlink" title="相关定义："></a>相关定义：</h2><ul>
<li>运行环境：基于Chrome v8引擎的javascript (REPL)</li>
<li>使用了事件驱动、非阻塞式I/O的模型，使其轻量而又高效；<ul>
<li>事件驱动： 当触发某个事件的时候，执行事件中指定的代码；</li>
<li>非阻塞式I/O的模型：采用非阻塞的操作，能够提高处理效率</li>
</ul>
</li>
<li><u>总结：node.js就是一个javascript的服务端运行唤醒，为javascript提供了服务端编程能力</u></li>
</ul>
<h2 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h2><ul>
<li>除过自定义模块引入都使用：var 变量名 = require(‘模块名’);<br>////注意模块名是使用npm安装时用的名字，也是package.json中的名字；</li>
<li>自定义模块的引入：var 变量名 = require(‘模块路径’);<br>/// 自定义模块引入需要写模块路径；</li>
</ul>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><ul>
<li>作用：操作文件</li>
<li>导入：var fs = require(‘fs’); ///导入fs核心模块；</li>
<li><p>读取文件内容：fs.readFile(‘path’,[字符编码],callback);</p>
<ul>
<li>第一个参数为要读取的文件路径；</li>
<li>第二个参数为字符编码可选；</li>
<li>第三个参数为回调函数：回调函数有两个参数:（error,data） ///当文件读取完成后执行回调函数；如果读取失败error是一个对象,data为undefined ,反之error为null,data为读取的内容；</li>
<li><p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;./files/1.txt&apos;, &apos;utf-8&apos;, (err, dataStr) =&gt; &#123;</div><div class="line">  if (err) return console.log(err.message);</div><div class="line">  console.log(dataStr);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>文件的写入：fs.writeFile(path,content,字符编码/可选,callback);</p>
<ul>
<li>四个参数：</li>
<li><p>callback：当文件写入完成后执行，参数只有一个error，如果写入失败error是一个对象，反之error为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(&apos;./files/2.txt&apos;, &apos;QQQ&apos;, (err) =&gt; &#123;</div><div class="line">     if (err) throw err;</div><div class="line">     console.log(&apos;写入OK&apos;);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>追加内容：fs.appendFile(path,content,字符编码/可选,callback);</p>
<ul>
<li>参数也有四个：</li>
<li>callback在文件写入完成后执行；参数只有一个，error同writeFile()一样；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(&apos;./files/3.html&apos;, &apos;&lt;h1&gt;首页&lt;/h1&gt;&apos;, (err) =&gt; &#123;</div><div class="line">    if (err) throw err;</div><div class="line">    console.log(&apos;OK&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><u>注意：使用者两种写入的方法写入内容时，如果要追加内容的文件不存在，不会报错</u></p>
</li>
<li><p>模块路径问题：<br>使用fs模块操作文件时：./的含义并不是当前文件路径；而是打开命令行的路径；所以如果使用./会从命令行所在的目录开始查找；</p>
</li>
</ul>
</li>
<li>为解决如上./路径问题,node中提供了一个关键字 ：_<em>dirname  //注意是两个 </em> ;</li>
</ul>
<p><u>在使用fs模块时，涉及到路径拼接时都要使用__dirname </u></p>
<h3 id="http模块；"><a href="#http模块；" class="headerlink" title="http模块；"></a>http模块；</h3><ul>
<li>作用：创建一个web服务器；</li>
<li>导入：var http = require(‘http’);</li>
<li>eg：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">// 2. 创建一个Web服务器</div><div class="line">var server = http.createServer();</div><div class="line"></div><div class="line">// 3. 先指定服务器要运行的端口号，再启动服务器</div><div class="line">server.listen(3000, () =&gt; &#123;</div><div class="line">  // 当服务器启动Ok之后，会调用回调函数</div><div class="line">  console.log(&apos;Server running at http://127.0.0.1:3000&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 4. 监听客户端的请求，并处理请求，最后把处理的结果通过网络返回给客户端</div><div class="line"></div><div class="line">// server.on(&apos;request&apos;) //为服务器绑定请求事件，每当有新的客户端请求我们服务器的时候，都会触发这个事件</div><div class="line">// req 是 request 的缩写：每当有请求过来，都能拿到这次请求的 Request 对象；通过 request 对象，能够拿到客户端提交过来的数据、报文头、报文体；</div><div class="line">// res 是 response 的缩写：服务器处理完这次请求之后，可以通过 response 对象，把处理的结果返回给浏览器</div><div class="line"></div><div class="line">server.on(&apos;request&apos;, (req, res) =&gt; &#123;</div><div class="line">  console.log(&apos;有新的请求过来了！！！&apos;);</div><div class="line">    // 通过 response 对象的 write 方法，向客户端写入数据</div><div class="line">  res.write(&apos;OK&apos;);</div><div class="line">  res.write(&apos;123&apos;);</div><div class="line">  res.write(&apos;456&apos;);</div><div class="line">  ///写入完成需要调用res的end()方法告诉服务器已经发送完毕，客户端可以显示了；</div><div class="line">  res.end();</div></pre></td></tr></table></figure>
<ul>
<li>res.end();<ul>
<li>如果一次就将将数据发送完了，也可以直接将响应的内容作为该方法的参数返回；</li>
<li>该方法的参数只能是字符串；</li>
</ul>
</li>
<li><p>res.writeHeader(); 写入响应头：</p>
<ul>
<li><p>格式：</p>
<blockquote>
<p>response.writeHead(statusCode, [reasonPhrase], {键：值})<br>eg:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response.writeHead(200, &#123;</div><div class="line">    &apos;Content-Length&apos;: body.length,</div><div class="line">    &apos;Content-Type&apos;: &apos;text/plain; charset=utf-8&apos;   ////规定响应文件的类型；</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>作用：解决中文乱码问题；</p>
</li>
<li>从定向</li>
</ul>
</li>
</ul>
<h3 id="node中Javascript"><a href="#node中Javascript" class="headerlink" title="node中Javascript"></a>node中Javascript</h3><ul>
<li><p>组成：ECMAscript+核心API+其他第三方API</p>
</li>
<li><p>运行环境:REPL</p>
</li>
<li><p>只能运行js自带的原生语法（alert不能识别）；</p>
</li>
<li><p>readFile(‘文件路径’，’文件路径’,function(error,data){</p>
<p> })  ////当文件读取成功是error为null;</p>
</li>
<li><p>函数定义</p>
</li>
<li>前端：箭头函数：（）=&gt;{}  ///():参数列表；{}：函数体；<ul>
<li>箭头函数中的this始终指向它外部作用域的的this;</li>
</ul>
</li>
</ul>
<h1 id="核心模块（API模块）"><a href="#核心模块（API模块）" class="headerlink" title="核心模块（API模块）"></a>核心模块（API模块）</h1><h3 id="fs-1"><a href="#fs-1" class="headerlink" title="fs"></a>fs</h3><ul>
<li>文件读取模块；</li>
<li>调用：var fs = require(‘fs’);</li>
<li>文件读取： fs.readFile(),有三个参数，<ul>
<li>第一个参数为：path，指定要读取的的文件路径；</li>
<li>options（可选），指定文件编码；</li>
</ul>
</li>
</ul>
<h3 id="文件的写入和追加；"><a href="#文件的写入和追加；" class="headerlink" title="文件的写入和追加；"></a>文件的写入和追加；</h3><ul>
<li>需调用node的核心模块，require（’fs’）;<br>-</li>
</ul>
<ul>
<li>在写入的字符串中加/n表示换行；</li>
<li>文件追加时如果，要追加的文件不存在不会报错，会先创建文件在追加；</li>
<li>文件写入时如果要写入的文件不存在会直接报错，</li>
</ul>
<h3 id="fs模块中路径"><a href="#fs模块中路径" class="headerlink" title="fs模块中路径"></a>fs模块中路径</h3><ul>
<li><p><em> </em> dirname ():获取当前代码所在文件的路径 ( <em> </em>之间不能有空格)；</p>
</li>
<li><p>在代码中使用./ ：命令窗口打开的路径</p>
</li>
</ul>
<h3 id="页面中静态资源路径"><a href="#页面中静态资源路径" class="headerlink" title="页面中静态资源路径"></a>页面中静态资源路径</h3><ul>
<li>页面中静态资源的路径属于二次请求，浏览器会进行拼接处理后；</li>
<li>不能以./或者../开始</li>
</ul>
<h3 id="环境变量-path"><a href="#环境变量-path" class="headerlink" title="环境变量 path"></a>环境变量 path</h3><ul>
<li>可以让我们通过命令行快速启动应用；</li>
<li>path变量查找规则，现在当前目录中查找，如果当前目录里面没有，就去系统环境变量path变量中依次查找对应的文件夹，如果里面也有对应的exe程序则运行，否则直接报错；</li>
</ul>
<h3 id="小点集合"><a href="#小点集合" class="headerlink" title="小点集合"></a>小点集合</h3><ul>
<li>谷歌2008年创造出了世界解析js最快的引擎， chrome  v8；</li>
<li><p>javascript是单线程语言，javascript语言全部运行在主线程上；</p>
</li>
<li><p>多线程：程序员能主动开启子线程的语言就叫做多线程语言；</p>
</li>
<li><p>异步方式，例如异步文件读写不是主程序来完成的，而是主程序开启的子程序来完成的，主程序会继续进行后续的操作；</p>
</li>
<li><p>只有用户模块，是通过路径+标识符来引用，其他模块都是直接通过标识符引用；</p>
</li>
</ul>
<ul>
<li>nodejs中require加载模块，优先从缓存中加载<ul>
<li>好处：提高程序的运行速度；</li>
</ul>
</li>
</ul>
<ul>
<li>node的模块化基于comenjs，</li>
<li>commonjs是同步加载的规范，不适用与浏览器端，因为浏览器端不是本地加载的（客户端采用的是本地加载）</li>
<li><p>AMD,CMD(规范的区别)；</p>
</li>
<li><p>需要对seo友好的页面区域一般采用服务器端渲染，反之采用客户端渲染；</p>
</li>
<li><p>nodejs中回调函数的第一个参数都是error对象；</p>
</li>
<li><p>rep.end();  ////()中可以放字符串,二进制；</p>
</li>
<li><p>const 用来定义常量，（例如模块对象）；</p>
</li>
<li><p>对象静态资源的请求后台必须通过fs模块来读取；</p>
</li>
<li><p>获取请求的方式：req.method;</p>
</li>
</ul>
<p>###第三方模块，核心模块的调用：</p>
<ul>
<li>第三方模块调用在第三方package.json中查看main的路径指向的是哪个文件，就引用哪个文件；</li>
<li>在自己的package.json中查看安装的第三方模块的名字，直接require该名字；</li>
</ul>
<p>###node中实现模块化主要是通过，module ,require ,exports</p>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><ul>
<li>入口程序:一般放在根目录；</li>
</ul>
<p>###转译符</p>
<ul>
<li>/</li>
</ul>
<p>###后台的mvc模式</p>
<ul>
<li>c:业务逻辑</li>
<li>m:数据的增删改查；</li>
<li>v:前端页面；</li>
</ul>
<p>是针对整个项目而言的；而前端的mvc只针对页面而言；</p>
<p>###网页上的请求</p>
<ul>
<li>分为两种同步和异步，</li>
<li>同步请求会直接渲染在页面上，</li>
<li>异步不会，如ajax请求，ajax的回调函数会先获取数据，进行处理；</li>
</ul>
<p>###向请求的客户端发送响应头</p>
<p>###获取前台请求数据；</p>
<h3 id="nodejs中的事件绑定："><a href="#nodejs中的事件绑定：" class="headerlink" title="nodejs中的事件绑定："></a>nodejs中的事件绑定：</h3><ul>
<li>addListener</li>
<li>on(‘事件类型’,function(){});</li>
</ul>
<p><u>不能用addEventListener</u></p>
<p>###浏览器主动发起的请求都是get，</p>
<p>###ES6javascript新语法特性</p>
<ul>
<li>结构赋值</li>
<li>模板字符串；</li>
<li><p>array.some(function(val ,index){</p>
<p>  return true ///当执行该语句时会终止循环；</p>
</li>
</ul>
<pre><code>})  ////遍历数组，找到满足要求项目，然后return true终止循环；
</code></pre><p>###核心模块url</p>
<ul>
<li>作用：可以通过它来解析获取获取客户端每次请求的ulr地址；<br>-</li>
</ul>
<p>###const let</p>
<ul>
<li>let:用它定义的变量不能预解析；同时会产生块级作用域({}可以分割作用域)；</li>
<li>const 定义常量，定义之后不能进行更改，同时也会产生块级作用域；<br>-</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/26/ajax补充/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/26/ajax补充/" itemprop="url">ajax补充</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-26T16:55:33+08:00">
                2016-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <style>
 div{
    padding:20px;
  }

  *{

   font-family:'楷体';
   font-size:16px;
  }
  h3,h1,h2{
   color:yellowgreen;
   font:30px '隶书';
  }
  u{

   color:red;
   font-size:14px;

  }
  ol{
   font-weight:900; 
  }


</style>

<h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><ul>
<li>定义：超文本传输协议，网站是基于HTTP协议的。（例如：网站的图片，css,js等都是通过http协议进行传输的）</li>
<li><p>作用：对从客户端到服务器的请求和从服务器到客户端的响应进行了约束和规范；</p>
</li>
<li><p>构成：主要由请求报文和响应报文构成：</p>
</li>
</ul>
<p>###请求/请求报文：</p>
<ul>
<li>请求行：请求方式，url地址；</li>
<li>请求头：</li>
<li>请求主体：</li>
</ul>
<h3 id="响应-响应报文"><a href="#响应-响应报文" class="headerlink" title="响应/响应报文"></a>响应/响应报文</h3><ul>
<li>状态行；协议版本号,状态码，状态信息；</li>
<li>响应头；</li>
<li>响应主体；</li>
</ul>
<h3 id="ajax（Asynchronous-Javascript-And-XML）"><a href="#ajax（Asynchronous-Javascript-And-XML）" class="headerlink" title="ajax（Asynchronous Javascript And XML）"></a>ajax（Asynchronous Javascript And XML）</h3><ul>
<li>ajax不是一门新的语言，而是对现有技术的综合利用；</li>
<li><p>本质：实在http协议的基础上以异步的方式与服务器进行通信；</p>
</li>
<li><p>利用浏览器内建的异步对象XMLHttpRequest来完成；</p>
</li>
</ul>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><ul>
<li>浏览器内建的异步对象，用于在后台与服务其通信，由此来实现对网页的局部更新；</li>
<li>本质基于http协议实现通信，所以其书写规则也满足http协议的要求；</li>
<li><p>请求：</p>
<ul>
<li><p>get方式：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">        //创异步对象；</div><div class="line">var xml = new XMLHttpRequest();</div><div class="line">//设请求行；</div><div class="line">xml.open(&apos;get&apos;, &apos;1.php?age=18&amp;name=张三&apos;);</div><div class="line">////设请求头；</div><div class="line">xml.setRequestHeader(&apos;header&apos;,&apos;123&apos;);</div><div class="line">///回函数；</div><div class="line">xml.onload = function () &#123;</div><div class="line">  console.log(xml.responseText);</div><div class="line">&#125;</div><div class="line">//请求主体；</div><div class="line">xml.send(null);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><u>get方式时可以不用设置请求头：不写设置语句或者随意写一个键值对，但不能空着，不然会报错的</u></p>
<p><hr></p>
<pre><code>- post方式：

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">///创异步对象；</div><div class="line">var obj = new XMLHttpRequest();</div><div class="line">////设请行；</div><div class="line">obj.open(&apos;post&apos;,&apos;1.php&apos;);</div><div class="line"></div><div class="line">/////设请求头；</div><div class="line">obj.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);</div><div class="line"></div><div class="line">//回调函数；</div><div class="line">obj.onload = function()&#123;</div><div class="line">    console.log(obj.responseText);</div><div class="line">&#125;</div><div class="line">///请求主体；</div><div class="line">obj.send(&apos;name=张三&amp;age=28&amp;XB=男&apos;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><ul>
<li>是javascript的事件的一种；</li>
<li>作用：监听XMLHttpRequest的状态；</li>
</ul>
<hr>
<p>1.获取状态行：</p>
<pre><code>- xhr.status //状态码；
- xhr.statusText //状态信息；
</code></pre><p>2.获取响应头：</p>
<pre><code>- xhr.getResponseHeader(&apos;Content-Type&apos;);//获取指定的头信息；
- xhr.getAllResponseHeader();//获取所有的响应头信息；
</code></pre><p>3.响应主体：</p>
<pre><code>- xhr.responseText;
- xhr.responseXML;
</code></pre><ul>
<li>eg:（检测XMLHttpRequest,并设置给选中的标签中设置内容）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</div><div class="line">      var result = document.querySelector(&apos;.result&apos;);</div><div class="line">      result.innerHTML = xhr.responseText;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">xhr.readyState = 4时，DONE响应完成；</div></pre></td></tr></table></figure>
<h3 id="DOMContentLoad和window-onload："><a href="#DOMContentLoad和window-onload：" class="headerlink" title="DOMContentLoad和window.onload："></a>DOMContentLoad和window.onload：</h3><ul>
<li>两者都是原生js的属性；</li>
<li>区别：DOMContentLoad事件是在DOM加载完毕，页面内容（如图片加载完毕之前执行。），与jquery中的入口函数相同。而window.onload会在页面资料全部加载完毕后才会执行。<br><u>总结：DOMContentLoad是在DOM渲染完毕，页面DOM元素可使用，触发，window.onload是在DOM渲染完毕，并且所有外部资源也加载完毕才触发；</u></li>
</ul>
<h3 id="入口函数；"><a href="#入口函数；" class="headerlink" title="入口函数；"></a>入口函数；</h3><ul>
<li><p>原生js入口函数：</p>
<ul>
<li>window.onload;</li>
</ul>
</li>
<li><p>jquery入口函数：：</p>
<ul>
<li>$(function(){});</li>
<li>$(document).read(function(){});</li>
</ul>
</li>
</ul>
<ul>
<li>区别：</li>
</ul>
<h3 id="DOM文档加载步骤："><a href="#DOM文档加载步骤：" class="headerlink" title="DOM文档加载步骤："></a>DOM文档加载步骤：</h3><p>1.解析HTML结构；<br>2.加载外部脚本和样式文件；<br>3.解析并执行脚本代码；<br>4.执行$(function(){})内对应的diamante；<br>5.加载图片等二进制资源；<br>6.页面加载完毕，执行window.onload;</p>
<h3 id="终止ajax请求的方法；"><a href="#终止ajax请求的方法；" class="headerlink" title="终止ajax请求的方法；"></a>终止ajax请求的方法；</h3><ul>
<li>创建XMLHttpRequest对象，创建的对象有一个abort()方法，可以通过该方法来终止ajax请求；</li>
</ul>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">发起HTTP GET请求获取指定URL的内容</div><div class="line">如果响应成功到达，则传入responseText给回调函数</div><div class="line">如果响应在timeout时间内没有到达，则中止请求</div><div class="line">浏览器可能会在abort()后出啊发readystatechange</div><div class="line">如果部分请求结果到达，甚至可能设置status属性</div><div class="line">所有需要设置一个标记，当部分且超时的响应到达时不会调用回调函数</div><div class="line">如果使用load(当请求完成时触发)事件就没有这个风险</div><div class="line">*/</div><div class="line">function(url,timeout,callback)&#123;</div><div class="line">    var request = new XMLHttpRequest();</div><div class="line">    var time = false;//是否超时</div><div class="line">    var timer = setTimeout(function()&#123;</div><div class="line">        timeout = true;</div><div class="line">        request.abort();//请求中止</div><div class="line">    &#125;,timeout);</div><div class="line">    request.open(&quot;GET&quot;,url);</div><div class="line">    request.onreadystatechange = function()&#123;</div><div class="line">        if(request.readyState !==4) continue;//忽略未完成的请求</div><div class="line">        if(timeout) return;//忽略中止请求</div><div class="line">        clearTimeout(timer);//取消等待的超时</div><div class="line">        if(request.status === 200)</div><div class="line">            callback(request.responseText);</div><div class="line">    &#125;</div><div class="line">    request.send(null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><u>jquery中的调用$.ajax和$.get,$.post都会创建一个加强版的异步对象XMLHtppReqest</u></p>
<h3 id="请求方式："><a href="#请求方式：" class="headerlink" title="请求方式："></a>请求方式：</h3><ul>
<li>get</li>
<li>post</li>
<li>put</li>
<li>delete;</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/22/高级面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/22/高级面向对象/" itemprop="url">高级面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-22T12:39:04+08:00">
                2015-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><style><br> div{<br>    padding:20px;<br>  }</p>
<p>  *{<br>   line-height:42px;<br>   font-family:’楷体’;<br>   font-size:16px;<br>  }<br>  h3,h1,h2{<br>   color:yellowgreen;<br>   font:30px ‘隶书’;<br>  }<br>  u{</p>
<p>   color:red;<br>   font-size:14px;<br>   line-height:24px;<br>  }<br>  ol{<br>   font-weight:900;<br>  }<br>  ul{<br>  font-size:8em;</p>
<p>  }</p>
<p></style></p>
<h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>1.<strong>基本数据类型与引用数据类型</strong></p>
<ul>
<li>基本数据类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">简单数据类型number,string,boolean,null,undefined</div></pre></td></tr></table></figure>
<ul>
<li>引用数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function,object,array</div></pre></td></tr></table></figure>
<p>2.<strong>全局变量都是window的属性</strong></p>
<ol>
<li><strong>delete用来删除对象的某一属性</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete 属性值；</div></pre></td></tr></table></figure>
<p>4.<strong>对象的属性可以是符合变量命名规则的任意值，所以数字也可以作为变量的属性</strong></p>
<p>5.<strong>对象属性的访问方式</strong></p>
<ul>
<li>对象.属性          //该方法不能访问数字属性</li>
<li>对象[属性的字符串]  //该方法最为强大 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：用【】的方式访问对象属性时，【】中写的是属性的字符串；</div></pre></td></tr></table></figure>
<p>6.<strong>面向对象与面向过程的概念；</strong></p>
<ul>
<li>面向过程：凡事都亲自做；</li>
<li>找别人帮忙做，没有可以做的人，就自己培养，培养好了再让他做，</li>
<li>关系：面向对象离不开面向过程，可以将面向对象理解成是对面向过程的封装；</li>
</ul>
<p>7.<strong>构造函数</strong></p>
<ul>
<li>定义：用new关键字创建实例的函数就是构造函数；</li>
<li>与普通函数的区别：仅仅是用途不同</li>
<li>函数名后面的括号：如果不需要穿参数，（）可以省略</li>
<li>返回值：构造函数会通过关键只new返回创建的对象，但若构造函数中有return,如果return返回的是一个基本数据类型，忽略，如果return返回的是一个复杂数据类形，则会替换new 创建出来的对象，返回这个复杂数据类型；</li>
</ul>
<p>8.<strong>类与实例：</strong></p>
<ul>
<li>类：一些相同特征事物的抽象描述，在js中可以将构造函数看作是类；</li>
<li>实例：一个实实在在的对象，具体真实存在的，js中构造函数创建的对象就是实例；</li>
</ul>
<p>9.<strong>类成员与实例成员；</strong></p>
<ul>
<li>成员：对象的属性和方法；</li>
<li>类成员（静态成员）：类的属性和方法；</li>
<li><p>实例成员：供实例使用的属性和方法；</p>
</li>
<li><p>两者的关系：实例成员类不能使用，类成员实例不能使用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：==原型对象中的成员虽然没有添加到实例身上，但却是为实例准备的所以他们也叫做实例成员。==</div></pre></td></tr></table></figure>
</li>
</ul>
<p>10.<strong>原型</strong></p>
<ul>
<li>原型是一个对象，任何对象都可以成为原型；</li>
<li><p>特点：属性和方法供其他对象共享；</p>
</li>
<li><p>使用：给构造函数的prototype父子一个对象，构造函数产生的实例就可以使用这个对象的方法和属性；</p>
</li>
<li>作用：节省内存；通常吧实例相同的部分放到原型对象中去定义；</li>
</ul>
<p>11.<strong>对象的查找规则</strong></p>
<ul>
<li>先在自身查找，</li>
<li>自身没有去原型对象内部查找；</li>
<li>原型对象中没有去他的上一级的原型对象中查找，</li>
<li>到原型链终点也没有找到，返回undefined；<br>12.<strong>对象的修改规则</strong></li>
<li>对象没有该属性，给对象添加该属性</li>
<li>有则直接修改；</li>
<li>修改一个对象的属性不会影响其他对象的属性，尤其不会影响原型对象；</li>
</ul>
<p>12.<strong>js中对象的创建</strong></p>
<ul>
<li>js中提供了四种对象字面量语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> 。。。。。。。 。        var o = &#123;&#125;;     //对象直面量</div><div class="line">var arr = [];    ///数组字面量</div><div class="line">var reg= /abc/;  ///正则字面量；</div><div class="line">var fn = function()&#123;&#125;;  ///函数字面量；</div></pre></td></tr></table></figure>
</li>
</ul>
<p>13.<strong>实例的类型</strong></p>
<ul>
<li>实例的类型与构造函数的名字有关；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eg:</div><div class="line">  new Array()  创建的是实例为Array类型；</div><div class="line">  new Person   创建的实例为Person类型；</div></pre></td></tr></table></figure>
<p>14.<strong>原型常见的三种写法</strong>`</p>
<ul>
<li>置换型  //频率最高；</li>
<li>调用jquery中的extend方法，给默认的原型 copy属性和方法；//频率次之；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125; $.extend(Person.prototype, &#123;&#125;, &#123;&#125;, &#123;&#125;)</div><div class="line">//将()中&#123;&#125;对象的属性和方法copy给Person的原型；</div></pre></td></tr></table></figure>
<ul>
<li>直接在默认的原型末尾添加属性或者方法： //频率最低；</li>
</ul>
<p>15.<strong>prototype和_ <em>proto</em> _</strong></p>
<ul>
<li>两者皆指向原型对象；</li>
<li>prototype是构造函数的属性，其指向那个对象表示构造函数的实例继承那个对象；</li>
<li><em> </em> proto <em> </em>是实例的属性，其指向谁表示实例继承谁；</li>
</ul>
<p>15.<strong>函数的三种调用模式：</strong></p>
<ul>
<li>函数调用模式(函数名（）||自调用函数)：this指向window </li>
<li>方法调用模式(对象.方法名||对象[方法名]||数组名[索引])：this指向最后一个对象 ； //注意数组中存放对象，或者函数；</li>
<li>构造器调用模式（ new  函数名（）||new 对象.方法名（））：this指向构造函数的实例；</li>
</ul>
<p>16.<strong>面向对象的三大特征</strong>；</p>
<ul>
<li>封装：属性和方法都集中在对象身上；</li>
<li>继承：对象可以使用其他对象的属性和方法，即为继承；</li>
<li>多态：js没有，但近似的可以把js对象随时随地的修改的特征认为是多态；</li>
</ul>
<h3 id="第三天；"><a href="#第三天；" class="headerlink" title="第三天；"></a>第三天；</h3><p>1.<strong>原型链</strong></p>
<ul>
<li>对象继承得所有对象，称为这个对象的原型链；</li>
<li>继承：一个对象可以使用另一个对象的属性和方法叫做继承；</li>
</ul>
<p>2.一些常见函数的原型链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Array ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">String ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">Object ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">Date ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">Function ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">Person ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">[] ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">new String ==&gt; String.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">new Object ==&gt; Object.prototype ==&gt; null;</div><div class="line">new Date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">new Function ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line">new Person ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null;</div><div class="line"></div><div class="line"></div><div class="line">- Math ==&gt; Object.prototype ==&gt; null;</div><div class="line">- JSON ==&gt; Object.prototype ==&gt; null</div></pre></td></tr></table></figure></p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul>
<li>运算规则：判断左边对象的原型链条中是否含有右边构造函数==当前==的prototype;</li>
<li>eg：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">		/**</div><div class="line">	 * instanceof：</div><div class="line">	 * 作用：判断1个对象的原型链中是否含有某构造函数的.prototype</div><div class="line">	 * 语法：对象 instanceof 构造函数</div><div class="line">	 * 运算规则：判断左边对象的原型链是否含有右边构造函数的prototype</div><div class="line">	 * */</div><div class="line">	</div><div class="line">	// 先创建实例，然后修改构造函数的prototype，</div><div class="line">	// 那么实例 instanceof 构造函数结果为</div><div class="line">	function Person()&#123;&#125;</div><div class="line">	var fengJie = new Person();</div><div class="line">	</div><div class="line">	// 后续修改构造函数的prototype属性，</div><div class="line">	// 是不会影响实例的__proto__属性的。</div><div class="line">	Person.prototype = &#123;</div><div class="line">		aaa: 1111</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	var furongJie = new Person();</div><div class="line">	</div><div class="line">	console.log(fengJie instanceof Person); // false</div><div class="line">	console.log(fengJie.aaa); // 不能访问</div><div class="line">	console.log(furongJie instanceof Person); // true</div><div class="line">	console.log(furongJie.aaa); // 可以访问</div><div class="line">--------------------------------------------------------------	</div><div class="line">	- Function instanceof Function ==&gt; true</div><div class="line">	</div><div class="line">	- Function instanceof Object ==&gt; true</div><div class="line">	</div><div class="line">	- Object instanceof Function ==&gt; true</div><div class="line">	</div><div class="line">	- Object instanceof Object ==&gt; true</div><div class="line">	分析：由于fengJie创建的时候，Person的prototype属性值还没有改变，所以就算之后Person该变，fengJie也仍然继承的是原先老的prototype;</div></pre></td></tr></table></figure>
<p>4.<strong>构造函数产生实例后，再更改构造函数的prototype属性，不会<br>  改变实例的原型链，即实例仍然继承更改前的prototype</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line"> var obj =new Person();</div><div class="line">Person.prototype = &#123;</div><div class="line">  b:456</div><div class="line">&#125;</div><div class="line">var obj1 =new Person();</div><div class="line"></div><div class="line">Person.prototype =&#123;</div><div class="line">   b:&apos;heheheh&apos;</div><div class="line">&#125;</div><div class="line">var obj2 =new Person();</div><div class="line"></div><div class="line">console.log(obj.b); //undefined</div><div class="line">console.log(obj1.b); //456</div><div class="line">console.log(obj2.b); //heheheh</div></pre></td></tr></table></figure>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><ul>
<li>作用：创建新对象，并自由指定新对象的集成结构；</li>
<li>语法：Object.create(新对象继承的对象（可以为null）),如果传入null，新对象没有继承结构；</li>
<li>这是ES5新增的集成方法</li>
<li>eg:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = Object.create(&#123;b:1234567&#125;);</div><div class="line">console.log(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><p>1.<strong>Function/eval</strong></p>
<p><strong><em>function</em></strong></p>
<ul>
<li>作用：创建函数的实例；</li>
<li><p>语法：new Function(形参1，形参2，…,代码体)//要求参数是字符串；</p>
<p><strong><em>eval</em></strong></p>
<ul>
<li>作用：把字符串作为代码执行；</li>
<li>语法：eval(字符串代码)；</li>
</ul>
</li>
</ul>
<p>共同点：都可以把字符串当作代码来执行；</p>
<h3 id="作用域相关概念："><a href="#作用域相关概念：" class="headerlink" title="作用域相关概念："></a><strong>作用域相关概念：</strong></h3><p>含义：变量的有效范围；</p>
<p><strong><em>全局作变量</em></strong></p>
<ul>
<li>概念：在代码的任意地方都可以访问的变量；</li>
<li>定义：在script标签内部，任意函数外部</li>
<li>生命周期：从定义开始到页面被卸载结束；</li>
</ul>
<p><strong><em>局部变量</em></strong></p>
<ul>
<li>概念：只有在定义该变量的函数内部才可以访问的变量叫做局部变量，</li>
<li><p>定义：在函数内部声明的变量；</p>
</li>
<li><p>生命周期：从函数执行，变量定义开始，通常到函数执行完毕结束</p>
</li>
<li>生命周期特列：如果有闭包函数引用了某局部变量，那么这个局部变量的生命周期就和闭包进行了绑定。（同时死亡）</li>
</ul>
<p><strong><em>作用域规则</em></strong></p>
<ul>
<li>函数作用域：只有函数才可以划分作用域，</li>
<li>块级作用域：凡是代码块就可以划分作用域：（用{}括起来的一段代码就叫做代码块；）</li>
</ul>
<blockquote>
<p>块级作用域在js中不存在在,js中只有函数才可以划分作用域；</p>
</blockquote>
<ul>
<li><p>词法作用域（静态作用域）：变量查找，优先在当前作用域查找，没有就去定义该函数的上级作用域查找，一次类推，直到全局作用域，全局作用域也没有就报错；</p>
</li>
<li><p>作用域链：函数运行时可以访问的所有作用域称作作用域链；</p>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li><strong>队象的所有的继承对象</strong></li>
<li><strong>每个对象有_ <em>proto</em> _属性串联起来的原型统称原型链</strong></li>
<li><strong>具体体现</strong>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.实例先继承构造函数的prototype,再向上继承object.prototype</div><div class="line"></div><div class="line">2.原型链一般只有两层</div></pre></td></tr></table></figure>
<h3 id="实例成员与类成员"><a href="#实例成员与类成员" class="headerlink" title="实例成员与类成员"></a>实例成员与类成员</h3><ul>
<li><strong>实例成员</strong>:供实例使用的方法和属性</li>
<li><strong>类成员</strong>：供类使用的属性和方法；<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3></li>
<li><strong>一个对象的属性和方法供多个对象共享</strong></li>
<li><strong>任何对象都可作为原型</strong><h3 id="内置对象的特列math、json"><a href="#内置对象的特列math、json" class="headerlink" title="内置对象的特列math、json"></a>内置对象的特列math、json</h3></li>
<li><strong>math/json属于单列，不是构造函数，他们的原型链只有一层，object.prototype</strong></li>
<li><strong>==单列==</strong>：用 {}创建的对象都叫做单列；</li>
</ul>
<hr>
<h3 id="原型链的终点"><a href="#原型链的终点" class="headerlink" title="原型链的终点"></a>原型链的终点</h3><p><strong>object.prototype</strong></p>
<h3 id="prototype和-proto-的区别"><a href="#prototype和-proto-的区别" class="headerlink" title="prototype和_ proto _的区别"></a>prototype和_ <em>proto</em> _的区别</h3><ul>
<li><strong>prototype指定实例继承那个原型对象</strong></li>
<li><strong>_ <em>proto</em> _指定实例自身继承那个对象</strong></li>
</ul>
<h3 id="Fucntion-Object自身原型链"><a href="#Fucntion-Object自身原型链" class="headerlink" title="Fucntion,Object自身原型链"></a>Fucntion,Object自身原型链</h3><p>Function和Object本身的_ <em>proto</em> _都指Function向默认的原型Function默认的原型指向终点，</p>
<h3 id="构造函数ptototype更改；"><a href="#构造函数ptototype更改；" class="headerlink" title="构造函数ptototype更改；"></a>构造函数ptototype更改；</h3><ul>
<li><strong>用构造函数创建实例时，实例会永久继承构造函数当前的prototype属性，实力构造完毕后更改构造函数的prototype不会该实例的_ <em>proto</em> _</strong></li>
</ul>
<p>2，<strong>复杂数据类型又叫做引用数据类型；</strong></p>
<ul>
<li>注意复杂数据类型作为参数，传递的是其地址，</li>
<li>注意在函数内部形参相当于局部变量；</li>
<li><img src="E:\YouDao_images\f0f77b497334984bb87e2ac0eeb38956.png" alt="image"></li>
<li></li>
</ul>
<hr>
<p>1.<strong>Function内置的构造函数</strong></p>
<ul>
<li>配合new可一用来创建函数；</li>
<li>所传参数为字符串，函数体为它里面的字符串文本；</li>
</ul>
<p>2.<strong>eval一个全局函数；</strong></p>
<ul>
<li><p>语法：eval(字符串代码)；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval(&apos;alert(&apos;一只小狗&apos;)&apos;)；</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><ul>
<li>来自Object.prototype,所有的对象都可以使用；</li>
<li>用法：判断对象自身是否含有指定的属性；</li>
<li><p>eg:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj =  &#123;</div><div class="line">     a:123,</div><div class="line">     b:&apos;哈哈&apos;</div><div class="line"> &#125;</div><div class="line"> console.log(obj.hasOwnProperty( &apos;a&apos;))</div></pre></td></tr></table></figure>
</li>
<li><p><u>注意：判断的是自己的属性，继承来的属性，不算；</u></p>
</li>
</ul>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><ul>
<li>检测对象是否可以使用某属性</li>
<li>不一定非要是自己的属性，继承的属性也算，</li>
<li>==in是一个运算符；==</li>
<li>==hasOwnProperty 是对象的方法；==</li>
</ul>
<p>4.<strong>数组也可以用for(key  in)的方法遍历，key中放的是数组的索引；</strong></p>
<p>6.<strong>creat</strong></p>
<p>7.<strong><em> </em> proto <em> </em>又叫隐式原型属性；<br>  prototype 又叫显式原型属性；</strong></p>
<p>8.<strong>函数作用域，</strong></p>
<ul>
<li>只有函数才可以分割作用域；js是函数作用域；</li>
<li>js中没有块级作用域；</li>
</ul>
<p>9.<strong>常量定义规范：</strong></p>
<ul>
<li>全部字母大写；</li>
<li>不同单词间用_隔开；</li>
<li>10，<strong>词法作用域</strong></li>
<li><p>eg:<br><img src="E:\YouDao_images/fd644ce82ecba9489f87db11a4e2e4b1.png" alt="image"></p>
</li>
<li><p>函数每调用一次就会产生一个新的作用域；</p>
</li>
<li>eg:<br><img src="" alt="image"></li>
</ul>
<p>11.<strong>函数在被定义的时候上级作用域链就被确定了，函数每次被调用就会产生一个新的作用域</strong></p>
<p>12.<strong>变量的声明</strong></p>
<ul>
<li>变量声明一定是通过关键子var</li>
<li>变量声明语句中通常会含有赋值表达式，但赋值表达式不属于变量的声明；</li>
<li>注意预解析只是将变量的声明提前；</li>
</ul>
<p>13，<strong>函数的声明：</strong></p>
<ul>
<li>一定是以关键之function 开头；</li>
<li>一定要有名字；</li>
<li>只有函数声明才能预解析；</li>
</ul>
<p>14，<strong>预解析也分为全局环境下的预解析，和局部环境下预解析</strong></p>
<p>15，<strong>预解析重名情况处理</strong></p>
<ul>
<li>变量重复声明后面的忽略</li>
<li>函数重名后面的优先级最高  保留后面的，</li>
<li>变量与函数重名保留函数；</li>
<li></li>
</ul>
<p>16，<strong>局部作用域中形参的优先级最高，先定义与声明；==但结果不一定会保留下来==</strong></p>
<h3 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h3><p>1.<strong>函数调用</strong></p>
<ul>
<li>先在被调用的函数内部，没有再去定义该函数的作用域查找都没有报错；</li>
<li></li>
</ul>
<p>2.yu</p>
<h3 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h3><p>1.<strong>递归</strong></p>
<ul>
<li>函数自己直接或者间接的调用自己称为递归；</li>
<li>2.console.log一次可以打印多个值，但alert只能打印一个值。</li>
<li>递归的特点；<br>-</li>
</ul>
<p>-总结：理论上递归和循环可以互换；<br>-递归比较耗性能，能少用就少用；</p>
<p>1.<strong>注意：使用border-radius，让一个盒子变为圆形时要考虑边框，padding等</strong></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>概念：引用了外部局部变量的函数就是闭包；</li>
<li>特点：1.会延长所引用变量的生命周期，<br><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.让外界可以访问原本访问不到的局部变量；
</code></pre></li>
</ul>
<h3 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply"></a>call与apply</h3><ul>
<li>call语法：函数.call(自定义this指向，实参1，实参2，实参3，…)</li>
<li>apply语法1：函数.apply(自定义this指向，【实参1，实参2，…】)     //后面跟的是一个参数数组</li>
<li><p>apply语法2：函数.apply(自定义this指向，{实参对象})</p>
</li>
<li><p>使用场景：1.使用数组的方法操作伪数组，<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;  2.借用Object.prototype上的toString获取对象的具体类型；<br>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&#123;&#125;).toString.call(data).</div></pre></td></tr></table></figure>
</li>
<li><p>构造函数借用，复用代码；</p>
</li>
</ul>
<div style="border:1px solid red;padding:10px;color:blue;font-size:16px;margin-top:20px;"><br> - 方法注意事项：<br><br> 1.被借用的方法内部操作的一定要是this否则借用了也没啥卵用；<br><br> 2.被借用的方法内部所需的属性，自定义的this对象也有；<br> —通常我们借用数组的方法操作伪数组，因为伪数组和数组很像；<br></div>


<h3 id="this补充"><a href="#this补充" class="headerlink" title="this补充"></a>this补充</h3><ul>
<li>看到new那么this就为最后函数的视力</li>
<li>看到call或apply那么就为传入的第一个参数；</li>
<li>剩下的两种情况，如果是函数名直接调用或者自调那么就为window;</li>
<li>否则就是方法调用了，this为最后那个对象；</li>
<li>注意this的指向与函数的声明位置无关，至于函数的调用方式有关；<h3 id="执行环境："><a href="#执行环境：" class="headerlink" title="执行环境："></a>执行环境：</h3></li>
<li>代码执行时依赖的东西；<h3 id="一般代码的执行过程："><a href="#一般代码的执行过程：" class="headerlink" title="一般代码的执行过程："></a>一般代码的执行过程：</h3></li>
<li>执行环境分为全局执行环境和局部执行环境。</li>
<li>js代码执行时默认就会进入全局执行执行环境，当遇到函数调用时就会进入进入一个独立的局部执行环境；</li>
<li>全局环境中含有：<ul>
<li>this</li>
<li>变量对象；</li>
</ul>
</li>
<li>局部环境中含有：<ul>
<li>this;</li>
<li>变量对象；</li>
<li>记录作用链的属性；</li>
</ul>
</li>
</ul>
<p>-<strong><em>具体执行过程</em></strong></p>
<p><div style="background:pink"><b><br>首先会初始化一个全局运行环境，初始化变量对象（预解析），全局代码逐行执行；<br><br>执行时如果遇到函数调用，俺么就创建一个新的局部运行环境，局部环境创建完成后局部代码逐行执行；<br><br>然后以此类推；</b></div></p>
<p><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">每一个函数执行完成后，都会尝试释放对应的局部运行环境；但有有些时候引文闭包的存在，有些变量对象是无法被释放掉的。</div></pre></td></tr></table></figure></p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>变量声明一定是通过关键字var定义的;</li>
<li>如果是连续声明变量，只有用  ，  连接才是对所列出的全部变量的声明；如果用 = 连接，仅仅是对第一个变量进行了声明；<br>eg:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(a); ///undefined;</div><div class="line">console.log(b);  ////报错；</div><div class="line">console.log(c); //报错；</div><div class="line">var a = b = c = 2;</div><div class="line"></div><div class="line">var e, f = j = 20;</div><div class="line">ef是变量的声明,j不是；</div></pre></td></tr></table></figure>
<p><u> 注意:如果js中只有函数才可以划分作用域，如果变量再说if(false){var a=3;} 声明，在if语句外面打印a，是不会报错的</u></p>
<ul>
<li>赋值表达式不属于变量声明，所以预解析不会讲它提前；</li>
<li><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3></li>
<li>以function关键字开头定义；</li>
<li>要么声明在全局作用域，要么声明在局部作用域（另一个函数的函数函数提前是内）；</li>
<li>函数一定有名字</li>
</ul>
<p><u>除此之外的都不是函数的声明（多为函数表达式）；</u></p>
<h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ul>
<li>概念：代码执行前先执行一部分；</li>
<li><p>具体做的事情：</p>
<pre><code>- 变量声明提升；
- 函数声明提升；
</code></pre></li>
<li><p>特点：</p>
<pre><code>- 在变量声明前访问该变量不报错；
- 在函数声明前调用该函数不报错；
</code></pre></li>
<li>规则：<pre><code>- 变量重名：后面的变量声明忽略；
- 函数重名：保留后面声明的函数；
- 变量与函数重名：保留函数声明，变量的声明被覆盖掉了；
- 局部预解析时，会先定义形参，然后再变量声明与提升函数声明；
</code></pre></li>
</ul>
<p>加强版，</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>作用：可以认为是forEach的加强版本，不光可以遍历数组的，而且还有返回值；这个返回值有我们来确定，通常用来通过一组数据映射出另外一组数据；</li>
<li>参数：<ul>
<li>第一个参数：回调函数 ；</li>
<li>第二个参数：指定毁掉函数中this的指向；</li>
</ul>
</li>
<li>回调函数的第一个参数：数组中的每一个元素；</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter:"></a>filter:</h3><p>-作用：过滤数组中的值得到新的数组；<br>-语法： 数组.filter（function（数组元素，索引，新的数组）{</p>
<p>  if(v%2==0)  ///返回数组中的偶数元素；<br>  return v;</p>
<p>}）</p>
<h3 id="EC严格模式；"><a href="#EC严格模式；" class="headerlink" title="EC严格模式；"></a>EC严格模式；</h3><ul>
<li>全局严格模式；<br>在整个代码的前面添加：’use strict’;全部代码都严格执行；</li>
<li>局部严格模式；<br>在函数前面添加’use strict’，然后只有函数是严格模式执行；</li>
</ul>
<ul>
<li>开启方法：在代码最前面添加：’use strict’;</li>
<li>严格模式下的一些新的表现：<ul>
<li>变量声明必须使用关键字vathisr不然会报错；</li>
<li>函数调用模式下，this不在指向实参window,而是undefined，其他区调用模式this指向不受影响；</li>
<li>禁止使用with语句语句;</li>
<li>call与apply真正实现了call谁就是谁；</li>
<li>禁用caller/callee;</li>
<li>arguments与形参不在绑定；（默认情况下arguments和形参有一个绑定关系，任何一方修改，另一方也会随之改变； ）<br>-若要使用ES6，ES7的语法必须使用严格模式；</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-caller是函数的属性，用来获取调用该函数的函数；</div><div class="line">-callee是arguments的属性，用来获取arguments所在的地方函数自己；</div></pre></td></tr></table></figure>
<p><u>在正常模式下，如果call的是简单数据类型，this会指向起对应的基本包装类型，但是null和audefined没对应的包装类型，所以指向的时间window,</u></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>概念：函数的直接或者间接调用自己；</li>
<li>特点：<ul>
<li>一定存在临界条件下，不然就是死提递归；</li>
<li>在递归过程中，每次会使用上一次的计算结果；</li>
</ul>
</li>
<li>补充：<ul>
<li>递归和循环理论上是可以互换的；</li>
<li>递归性能在大部分语言中性能都不高；</li>
</ul>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul>
<li><p>typeof null  //结果问object;</p>
</li>
<li><p>数据库导入的完毕初次运行node.js时要出入如下这句话：<br> npm install express  npm link mysql</p>
</li>
</ul>
<h3 id="函数与变量重名"><a href="#函数与变量重名" class="headerlink" title="函数与变量重名"></a>函数与变量重名</h3><ul>
<li>函数的声明会将变量的声明覆盖掉；</li>
<li>注意区分变量的声明与赋值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a=10;</div><div class="line"> console.log(typeof a);  </div><div class="line"> function a()&#123;&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<ul>
<li>分析： 函数的神明会将变量的声明覆盖掉，所以相当于只声明了一个函数a，但之后通过赋值符将函数a的值该为10，所以打印的结果 为：number</li>
<li>如果写成如下格式，打印结果为function;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(typeof a); </div><div class="line">var a=10;</div><div class="line"> function a()&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="函数的prototype"><a href="#函数的prototype" class="headerlink" title="函数的prototype"></a>函数的prototype</h3><ul>
<li>为该函数添加一个原形（即 prototype）属性 </li>
<li>为 prototype 对象额外添加一个 constructor 属性，并且该属性保存指向函数该函数的一个引用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
